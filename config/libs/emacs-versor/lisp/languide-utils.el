;;; languide-utils.el --- utility functions for languide

;; Copyright (C) 2007  John Sturdy

;; Author: John Sturdy <jcgs@hosea>
;; Keywords: convenience

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:

;; 

;;; Code:

(defvar languide-auto-edit-overlays nil
  "Highlights added by languide to show what it has done.
Cleared at the start of each command.")

(defun languide-insertion (fn insertions)
  "Apply FN to INSERTIONS.
Handler for things like insert, remembering that languide did the
insertions.  This allows languide to highlight things to show the
user what it has done."
  (let ((start (point)))
    (apply fn insertions)
    (let* ((end (point))
           (overlay (make-overlay start end)))
      (overlay-put overlay 'face 'languide-auto-edit-overlay-face)
      (push overlay languide-auto-edit-overlays))))

(defun languide-insert (&rest insertions)
  "Like insert, but remembers that the INSERTIONS were done by languide."
  (languide-insertion 'insert insertions))

(defun languide-insert-before-markers (&rest insertions)
  "Like `insert-before-markers', but remembers that the INSERTIONS were done by languide."
  (languide-insertion 'insert-before-markers insertions))

(defun languide-remove-auto-edit-overlays ()
  "Remove any `languide-auto-edit-overlays'."
  (mapcar (lambda (o) (when (overlayp o) (delete-overlay o)))
          languide-auto-edit-overlays)
  (setq languide-auto-edit-overlays nil))

(add-hook 'pre-command-hook 'languide-remove-auto-edit-overlays)

(defun place-string (d)
  "Return a string describing the place around D."
  (if (integerp d)
      (format "%d:\"%s\"" d (buffer-substring-no-properties d (+ 20 d)))
    (format "%S" d)))

(defun choose-place-interactively (places order overlay-text-function overlay-text-args)
  "Let the user choose from PLACES, a list of positions in the current buffer.

PLACES are to be taken in ORDER, which is passed as the second
argument to sort.  Each of PLACES is marked by putting an overlay
on it, with an after-text generated by applying
OVERLAY-TEXT-FUNCTION to OVERLAY-TEXT-ARGS with point set to that
position.

The result of OVERLAY-TEXT-FUNCTION should be a list of three strings:
*  a preamble which will normally be whitespace to adjust indentation
*  the string of interest, which will be highlighted
*  a postamble, normally whitespace.

The user actions will leave point at one of the possible PLACES,
and the overlays are destroyed when the function finishes.

The user interface loosely mimics that of isearch."
  (let* ((index 0)
         (sorted (sort (copy-sequence places) order))
         (overlays nil)
         (this-one nil)
	 (current-choice isearch)
	 (others isearch-lazy-highlight-face))
    (unwind-protect
        (progn
          (setq overlays (mapcar #'(lambda (possibility)
                                     (setq index (1+ index))
                                     (save-excursion
                                       (goto-char possibility) ; so the function can find the indentation
                                       (let* ((overlay (make-overlay possibility possibility))
                                              (decl-texts (apply overlay-text-function overlay-text-args))
                                              )
                                         (overlay-put overlay 'after-string
						      (propertize
						       (concat (car decl-texts)
							       (cadr decl-texts)
							       "[" (int-to-string index) "]"
							       (nth 2 decl-texts))
						       'face others))
                                         (overlay-put overlay 'priority 2)
                                         overlay)))
                                 sorted)
                this-one (car overlays))
          (goto-char (overlay-start this-one))
	  (let ((string (overlay-get this-one 'after-string)))
	    (put-text-property 0 (1- (length string)) 'face current-choice string))
	  (message "Use up, down, digit to choose, and return to select a position")
	  ;; todo: could to this with overriding-terminal-local-map, but is it really worth it?
	  ;; todo: mouse-enable these overlays, if possible
          (let ((char (read-event))
                (n 0)
                (chosen nil))
            (while (not chosen)
              (cond
               ((memq char '(return 13))
                (setq chosen t))
               ((and (integerp char)
		     (>= char ?1)
                     (<= char ?9))
                (setq n (- char ?1))
                (if (>= n (length overlays))
                    (setq n (1- (length overlays)))
                  (setq chosen t)))
               ((memq char '(up left 18 ?p))
                ;; previous one
                (setq n (1+ n))
                (when (>= n (length overlays))
                  (setq n (1- (length overlays))))
                )
               ((memq char '(down right 19 ?n))
                ;; next one
                (setq n (1- n))
                (when (< n 0)
                  (setq n 0))
                )
               (t (message "up or down or return")))
	      (let ((string (overlay-get this-one 'after-string)))
		(put-text-property 0 (1- (length string)) 'face others string))
	      (setq this-one (nth n overlays))
              (let ((string (overlay-get this-one 'after-string)))
		(put-text-property 0 (1- (length string)) 'face current-choice string))
              (goto-char (overlay-start this-one))
              (unless chosen
		(setq char (read-event)))))
          (point))
      (mapcar 'delete-overlay overlays))))

(defmacro those-rel-limit (those rel limit)
  "Return members of THOSE that are REL to LIMIT."
  `(let ((result nil)
         (these ,those))
     (while these
       (when (,rel (car these) ,limit)
         (setq result (cons (car these) result)))
       (setq these (cdr these)))
     (nreverse result)))

(defun those<=limit (those limit)
  "Return members of THOSE that are less than or equal to LIMIT."
  (those-rel-limit those <= limit))

(defun those>=limit (those limit)
  "Return members of THOSE that are greater than or equal to LIMIT."
  (those-rel-limit those >= limit))

(provide 'languide-utils)
;;; languide-utils.el ends here
